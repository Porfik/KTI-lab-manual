# Инфраструктура в контейнерах
1. Docker
	1. Установка Docker
	2. Запуск контейнеров
	3. Сборка образа контейнера
2. Docker Compose
	1. Работа с контейнерами
	2. Переменные окружения
3. Автоматизация развёртки приложения
	1. Предварительные настройки окружения
	2. 

---

##### Цель работы:
>Получение навыков работы с контейнерами при помощи Docker и Docker Compose, а также автоматизации развёртки приложений.

---

## Docker
### Установка Docker

>[!WARNING]
>Данная лабораторная работа выполняется на новой виртуальной машине, созданной по [аналогии с первой](Lab_1/#создание-новой-вм).

>[!NOTE]
>В последней лабораторной работе рассмотрим другой подход развёртывания приложений и сопутствующей инфраструктуры, а именно — использование для этих задач изолированных сред: контейнеров. Мы будем использовать Docker  — это платформа для запуска приложений в изолированных средах (контейнерах).
>
>Docker-контейнеры — это самодостаточные программные модули, инкапсулирующие ПО и его зависимости: код, библиотеки, настройки окружения. В отличие от виртуальных машин, контейнеры используют ядро хост-системы и изолируют процессы на уровне ОС, что делает их более быстрыми и ресурсоэффективными. Это позволяет разработчикам создавать и тестировать приложения в одинаковых условиях независимо от окружения — будь то локальный компьютер, сервер или облачное хранилище.

Для начала установим Docker. Актуальное руководство по установке можно найти [здесь](https://docs.docker.com/engine/install/centos/). Рекомендуемый метод установки - настроить репозиторий и установить Docker из него.

```bash
sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
```

```bash
sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
```

![](../images/lab_4/4.png)

![](../images/lab_4/4.1.png)

После установки будет создана новая пользовательская группа с названием `docker`. Запустим службу Docker (заодно включив автозапуск) и добавим в неё своего пользователя:

```bash
sudo systemctl enable --now docker
```

```bash
sudo usermod -aG docker $USER
```

```bash
newgrp docker
```

![](../images/lab_4/4.2.png)

Перезапустим виртуальную машину и снова зайдём в группу `docker`.

```bash
newgrp docker
```

Проверить работоспособность Docker-а и правильно ли всё установлено можно командой:

```bash
docker container run hello-world
```

>[!NOTE]
>Эту команду используют в первую очередь для проверки корректности установки и настройки Docker: она скачивает (если ещё не загружен) специальный тестовый образ `hello-world` с [Docker Hub](https://hub.docker.com/), запускает на его основе контейнер, который выводит простое приветственное сообщение в терминал, подтверждая, что Docker работает должным образом, а затем завершает свою работу.

![](../images/lab_4/4.3.png)

Список доступных команд для работы с контейнерами в Docker можно посмотреть с помощью флага `--help`

```bash
docker container --help
```

![](../images/lab_4/4.4.png)

### Запуск контейнеров
>[!NOTE]
>В контейнерах запускаются процессы, определенные образами. Эти образы состоят из одного или нескольких слоев (или наборов различий) плюс некоторых метаданных. Один из способов взглянуть на образы и контейнеры — это рассматривать их как программы и процессы. Точно так же как процесс может рассматриваться «выполняемым приложением», контейнер может рассматриваться как образ, выполняемый докером.

 Запустим Docker-контейнер с уже знакомым нам веб-сервером NGINX, для этого выполним команду:

```bash
docker run -d nginx
```

>[!NOTE]
>`-d` (от detached) — флаг, указывающий Docker запустить контейнер в фоновом режиме, то есть без привязки к текущему терминалу. Это позволяет продолжать работу в командной строке, пока контейнер работает в фоне. 
>
>`nginx` — имя официального образа веб-сервера NGINX из Docker Hub.
>
>В результате команда запускает контейнер с NGINX, который начинает слушать HTTP-запросы (по умолчанию на порту 80 внутри контейнера), работая незаметно в фоне.

![](../images/lab_4/4.5.png)

Посмотреть список запущенных контейнеров можно командой:

```bash
docker container ls
```

А все контейнеры, даже остановленные — командой:

```bash
docker container ls -a
```

![](../images/lab_4/4.6.png)

>[!NOTE]
>В выводе команды отображаются следующие столбцы:
>`CONTAINER ID` — уникальный идентификатор контейнера;
>`IMAGE` — образ, на основе которого был создан контейнер;
>`COMMAND` — команда, которая была выполнена при запуске контейнера;
>`CREATED` — время, прошедшее с момента создания контейнера;
>`STATUS` — текущее состояние контейнера;
>`PORTS` — порты, которые использует контейнер;
>`NAMES` — имена контейнеров (в данном случае случайно сгенерированные), удобны для ссылки на контейнер вместо ID.

При помощи команды `docker inspect <container id>` можно узнать множество информации о контейнере (и не только). Например, узнать IP-адрес контейнера можно так:

```bash
docker inspect d3d07bb0590d | grep IPAddress
```

Или с помощью:

```bash
docker inspect d3d07bb0590d | jq ".[0].NetworkSettings.IPAddress"
```

![](../images/lab_4/4.7.png)

Зная IP-адрес контейнера, можно отправить http-запрос при помощи утилиты **curl**:

```bash
curl http://172.17.0.2
```

![](../images/lab_4/4.8.png)

В ответ получим текст странички со стандартным приветствием NGINX.

Однако при попытке открыть в браузере страницу по адресу нашей виртуальной машины мы не обнаружим ожидаемого приветствия.

![](../images/lab_4/4.9.png)

Все дело в том, что по умолчанию контейнер запускается изолированно. Используемые сетевые порты доступны внутри изолированной сети Docker, но не снаружи узла, на котором запущен контейнер. Узнаем, прослушивается ли порт 80.

```bash
ss -tpln | grep 80
```

![](../images/lab_4/4.10.png)



![](../images/lab_4/4.11.png)

![](../images/lab_4/4.12.png)

![](../images/lab_4/4.13.png)

![](../images/lab_4/4.14.png)

![](../images/lab_4/4.15.png)

![](../images/lab_4/4.16.png)

![](../images/lab_4/4.17.png)

![](../images/lab_4/4.18.png)

![](../images/lab_4/4.19.png)

```bash
docker container run -d -p 80:80 --rm --name nginx -v '/home/batman/KTI_lab_4/conf:/etc/nginx/conf.d' -v '/home/batman/KTI_lab_4/html:/usr/share/nginx/html' nginx
```

![](../images/lab_4/4.20.png)

![](../images/lab_4/4.21.png)

### Сборка образа контейнера

![](../images/lab_4/4.22.png)

![](../images/lab_4/4.23.png)

![](../images/lab_4/4.24.png)

![](../images/lab_4/4.25.png)

![](../images/lab_4/4.26.png)

![](../images/lab_4/4.27.png)

![](../images/lab_4/4.28.png)

![](../images/lab_4/4.29.png)

---

## Docker Compose
### Работа с контейнерами

![](../images/lab_4/4.30.png)

![](../images/lab_4/4.31.png)

![](../images/lab_4/4.32.png)

![](../images/lab_4/4.33.png)

![](../images/lab_4/4.34.png)

![](../images/lab_4/4.35.png)

![](../images/lab_4/4.36.png)

![](../images/lab_4/4.37.png)

![](../images/lab_4/4.38.png)

![](../images/lab_4/4.39.png)

![](../images/lab_4/4.40.png)

![](../images/lab_4/4.41.png)

![](../images/lab_4/4.42.png)

![](../images/lab_4/4.43.png)

![](../images/lab_4/4.44.png)

![](../images/lab_4/4.45.png)

![](../images/lab_4/4.46.png)

![](../images/lab_4/4.47.png)

### Переменные окружения



---

## Автоматизация развёртки приложения
### Предварительные настройки окружения